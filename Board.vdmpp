--
-- THIS FILE IS AUTOMATICALLY GENERATED!!
--
-- Generated at 30-Nov-15 by the UML-VDM++ Link
--
class Board

instance variables
public circles : seq of Circle;

operations
	public Board: () ==> Board
	Board() == (
	
		dcl WP1 : Archer := new Archer('W'); dcl WP2 : Archer := new Archer('W'); dcl WP3 : Archer := new Archer('W'); dcl WP4 : Archer := new Archer('W'); dcl WP5 : Archer := new Archer('W');
		dcl BP1 : Archer := new Archer('B'); dcl BP2 : Archer := new Archer('B'); dcl BP3 : Archer := new Archer('B'); dcl BP4 : Archer := new Archer('B'); dcl BP5 : Archer := new Archer('B');

		dcl A1 : Circle := new Circle('A','1',WP1);
		dcl B1 : Circle := new Circle('B','1',WP2);
		dcl C1 : Circle := new Circle('C','1',WP3);
		dcl D1 : Circle := new Circle('D','1',WP4);
		dcl E1 : Circle := new Circle('E','1',WP5);

		dcl A2 : Circle := new Circle('A','2');
		dcl B2 : Circle := new Circle('B','2');
		dcl C2 : Circle := new Circle('C','2');
		dcl D2 : Circle := new Circle('D','2');
		dcl E2 : Circle := new Circle('E','2');

		dcl A3 : Circle := new Circle('A','3');
		dcl B3 : Circle := new Circle('B','3');
		dcl C3 : Circle := new Circle('C','3');
		dcl D3 : Circle := new Circle('D','3');
		dcl E3 : Circle := new Circle('E','3');

		dcl A4 : Circle := new Circle('A','4');
		dcl B4 : Circle := new Circle('B','4');
		dcl C4 : Circle := new Circle('C','4');
		dcl D4 : Circle := new Circle('D','4');
		dcl E4 : Circle := new Circle('E','4');

		dcl A5 : Circle := new Circle('A','5',BP1);
		dcl B5 : Circle := new Circle('B','5',BP2);
		dcl C5 : Circle := new Circle('C','5',BP3);
		dcl D5 : Circle := new Circle('D','5',BP4);
		dcl E5 : Circle := new Circle('E','5',BP5);

		/*MOVES*/

		A1.setMoves({B3,C2});
		A2.setMoves({C1,C3});
		A3.setMoves({B5,B1});
		A4.setMoves({C5,C3});
		A5.setMoves({B3,C4});
		B1.setMoves({A3,D2});
		B2.setMoves({B3,C2,C4,D1});
		B3.setMoves({A5,A1,D2,B4,B2,C5});
		B4.setMoves({B3,C4,D3,D5});
		B5.setMoves({A3,D4});
		C1.setMoves({A2,E2,D3});
		C2.setMoves({B2,D2,E3,A1,E1});
		C3.setMoves({A4,A2,D1,E4});
		C4.setMoves({A5,B2,E5,B4,D4});
		C5.setMoves({A4,A1,E4,B3});
		D1.setMoves({B2,C3});
		D2.setMoves({B1,C2,D3,B3});
		D3.setMoves({E5,E1,D2,D4,B4,C1});
		D4.setMoves({B5,C4,D3,E2});
		D5.setMoves({B4,E3});
		E1.setMoves({C2,D3});
		E2.setMoves({C1,D4});
		E3.setMoves({C2,D5});
		E4.setMoves({C3,C5});
		E5.setMoves({C4,D3});

		circles := [A1,B1,C1,D1,E1,
							A2,B2,C2,D2,E2,
							A3,B3,C3,D3,E3,
							A4,B4,C4,D4,E4,
							A5,B5,C5,D5,E5];

		return self;
	)
	post len circles = 25;
	
	public getCircleIndex: char*char ==> nat
	getCircleIndex(column, row) ==
	(
		for i = 1 to len circles by 1 do
			if circles(i).column = column and circles(i).row = row then
				return i;
		return 99;
	)
	pre (column = 'A' or column = 'B' or column = 'C' or column = 'D' or column = 'E') and
	(row = '1' or row = '2' or row = '3' or row = '4' or row = '5')
	post RESULT<=25;
	
	public getCircle: nat ==> Circle
	getCircle(i) ==
	(
		return circles(i);
	)
	pre i<=25;
	
	public gameEnded: () ==> bool
	gameEnded() ==
	(
		for circle in circles do
			if circle.archer <> nil then (
				if circle.archer.color = 'B' and circle.row <> '1' then
					return false;
				if circle.archer.color = 'W' and circle.row <> '5' then
					return false);
		return true;
	);
	
	public getScore: char ==> int
	getScore(color) ==
	(
		dcl score : int := 0;
		dcl row : char;
		if color = 'W' then
			row:='5'
		else
			row:='1';	
		for circle in circles do
			if circle.archer <> nil and circle.archer.color = color then
				if circle.row = row then
					score := score + 2
				else
					score := score + 1;
		return score;
	)
	pre color = 'W' or color = 'B'
	post RESULT>=0;
	
	public movePiece: nat * nat ==> ()
	movePiece(sourceIndex, destIndex) == 
	(
		dcl source : Circle := circles(sourceIndex);
		dcl destination : Circle := circles(destIndex);
		if destination.archer = nil or (destination.archer.color <> source.archer.color) then (
			destination.archer := source.archer;
			source.archer := nil
		);
	)
	pre sourceIndex <= 25 and destIndex <= 25 and circles(sourceIndex).archer <> nil and circles(destIndex) in set circles(sourceIndex).moves
	post circles(destIndex).archer = circles~(sourceIndex).archer and circles(sourceIndex).archer = nil;

end Board
